package cmd

import (
	"context"
	"encoding/csv"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/briandowns/spinner"
	rest "github.com/google/go-github/v41/github"
	graphql "github.com/shurcooL/githubv4"
	"github.com/spf13/cobra"
	"golang.org/x/oauth2"
)

var (
	token        string
	organization string
	repositories []Repository

	repoQuery struct {
		Organization struct {
			Repositories struct {
				PageInfo struct {
					EndCursor   graphql.String
					HasNextPage bool
				}
				Nodes []Repository
			} `graphql:"repositories(first: 100, after: $page, orderBy: {field: NAME, direction: ASC})"`
		} `graphql:"organization(login: $login)"`
	}

	httpClient    *http.Client
	restClient    *rest.Client
	graphqlClient *graphql.Client

	ctx = context.Background()

	rootCmd = &cobra.Command{
		Use:     "ghec-vulnerability-alerts-report",
		Short:   "Generate a report of vulnerability alerts enabled/disabled for all repositories in the organization.",
		PreRun:  GetOrgRepos,
		RunE:    Run,
		Version: "0.0.2",
	}
)

// Repository unexported
type Repository struct {
	Name string
}

// Execute adds all child commands to the root command and sets flags
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func init() {
	cobra.OnInitialize(initClient)

	rootCmd.PersistentFlags().StringVarP(
		&token, "token", "t", "GITHUB_TOKEN",
		"github.com personal access token",
	)
	token = os.Getenv("GITHUB_TOKEN")

	rootCmd.PersistentFlags().StringVarP(
		&organization, "organization", "o", "",
		"github.com organization",
	)
}

// initClient creates the github.com REST (v3) and GraphQL (v4) clients
func initClient() {
	src := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: token},
	)
	httpClient = oauth2.NewClient(ctx, src)

	graphqlClient = graphql.NewClient(httpClient)
	restClient = rest.NewClient(httpClient)
}

func Run(cmd *cobra.Command, args []string) error {
	// create a csv file and write the user to it
	file, err := os.Create("./vulnerability-alerts-report.csv")

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	defer file.Close()

	//create new csv writer
	writer := csv.NewWriter(file)

	header := []string{"owner", "repo", "vulnerability_alerts_enabled?", "admins"}
	writer.Write(header)

	s := spinner.New(spinner.CharSets[26], 100*time.Millisecond)
	s.Prefix = fmt.Sprintf("creating report for %s (this could take a while) ", organization)
	s.FinalMSG = fmt.Sprintf("done.\nreport saved in %s\n", file.Name())
	s.Start()

	for _, repo := range repositories {
		admins := GetRepoAdmins(organization, repo.Name)

		_, res, err := restClient.Repositories.GetVulnerabilityAlerts(ctx, organization, repo.Name)

		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}

		writer.Write([]string{
			organization,
			repo.Name,
			strconv.FormatBool(res.StatusCode == 204),
			strings.Join(admins, ","),
		})

		defer writer.Flush()
	}

	s.Stop()

	return nil
}

func GetOrgRepos(cmd *cobra.Command, args []string) {
	variables := map[string]interface{}{
		"login": graphql.String(organization),
		"page":  (*graphql.String)(nil),
	}

	for {
		err := graphqlClient.Query(ctx, &repoQuery, variables)

		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}

		repositories = append(repositories, repoQuery.Organization.Repositories.Nodes...)

		// break on last page
		if !repoQuery.Organization.Repositories.PageInfo.HasNextPage {
			break
		}

		variables["page"] = graphql.NewString(repoQuery.Organization.Repositories.PageInfo.EndCursor)
	}
}

// GetRepoAdmins returns a list of the admin users for a given repository
func GetRepoAdmins(owner string, repo string) []string {
	opt := &rest.ListCollaboratorsOptions{
		Affiliation: "all",
		ListOptions: rest.ListOptions{
			PerPage: 100,
		},
	}

	var admins []string

	for {
		users, res, _ := restClient.Repositories.ListCollaborators(ctx, owner, repo, opt)

		for _, user := range users {
			permissions := user.GetPermissions()

			if permissions["admin"] {
				admins = append(admins, user.GetLogin())
			}
		}

		// break if we have found more than one admin already
		if len(admins) > 0 {
			break
		}

		// break on last page
		if res.NextPage == 0 {
			break
		}

		opt.Page = res.NextPage
	}

	return admins
}
